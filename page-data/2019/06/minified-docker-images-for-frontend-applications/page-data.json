{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/06/minified-docker-images-for-frontend-applications/","result":{"data":{"site":{"siteMetadata":{"title":"dominikaschbacher.com"}},"markdownRemark":{"id":"df7d1e19-fc83-5d5a-b671-929542da9512","excerpt":"Nowadays many developers containerize their projects including json-apis and frontend applications.\nIn Go for example it is common to use multi-staged builds inâ€¦","html":"<p>Nowadays many developers containerize their projects including json-apis and frontend applications.\nIn Go for example it is common to use multi-staged builds in docker where in the first step a binary is being compiled\nfrom the source code and in the second step this file is being copied to an empty docker image that is build from scratch.</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token comment\"># Build</span>\n<span class=\"token keyword\">FROM</span> golang<span class=\"token punctuation\">:</span>1.12<span class=\"token punctuation\">-</span>alpine AS base\n<span class=\"token keyword\">COPY</span> . /go/src/github.com/dev/project\n\n<span class=\"token keyword\">WORKDIR</span> /go/src/github.com/dev/project\n<span class=\"token keyword\">RUN</span> apk add git gcc\n\n<span class=\"token comment\"># Go modules</span>\n<span class=\"token keyword\">ENV</span> GO111MODULE=on\n<span class=\"token keyword\">RUN</span> go mod download\n\n<span class=\"token comment\"># Compile</span>\n<span class=\"token keyword\">RUN</span> go build <span class=\"token punctuation\">-</span>a <span class=\"token punctuation\">-</span>tags netgo <span class=\"token punctuation\">-</span>ldflags <span class=\"token string\">'-w'</span> <span class=\"token punctuation\">-</span>o /go/bin/project /go/src/github.com/dev/project/main.go\n\n<span class=\"token comment\"># Package</span>\n<span class=\"token keyword\">FROM</span> scratch\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=base /go/bin/project /project\n<span class=\"token keyword\">ENTRYPOINT</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/project\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Multi-staged builds have the advantage of being much smaller than single-staged builds, where dependencies\nnecessary for the compiling process are also contained within the actual image used in production. Unfortunately\nmany developers containerizing frontend applications written in JavaScript (React, Angular, VueJS) use the same\nimage to build and to serve their frontend application.</p>\n<p>In this example I will use React to show you how to minify your Docker image to gain storage and also performance.\nIn React you can create a production build by using the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> run build</code></pre></div>\n<p>When the command finishes a new folder called <code class=\"language-text\">build</code> will appear in your project folder. This folder contains your\nfrontend application minified and ready to be executed. At this point you can manually execute the file <code class=\"language-text\">index.html</code>\nand you will get the same response as in development.</p>\n<p>Now we only need a web server that is capable of serving HTML-files\nand their assets, so pretty much every web server you can think of. In this example I will use Nginx because it is a\nvery fast, reliable and small web server that is also available as a Docker image.</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token comment\"># Build</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>11<span class=\"token punctuation\">-</span>slim AS base\n\n<span class=\"token comment\"># Workdir</span>\n<span class=\"token keyword\">RUN</span> mkdir /usr/src/app\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token comment\"># Add environment path</span>\n<span class=\"token keyword\">ENV</span> PATH /usr/src/app/node_modules/.bin<span class=\"token punctuation\">:</span>$PATH\n\n<span class=\"token comment\"># Compile static page</span>\n<span class=\"token keyword\">COPY</span> . /usr/src/app\n<span class=\"token keyword\">RUN</span> npm install\n<span class=\"token keyword\">RUN</span> npm run build\n\n<span class=\"token comment\"># Package</span>\n<span class=\"token keyword\">FROM</span> nginx<span class=\"token punctuation\">:</span>alpine\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=base /usr/src/app/build /usr/share/nginx/html</code></pre></div>\n<p>As you can see in the first stage the project is being build by using the official NPM Docker image\nand in the second stage the <code class=\"language-text\">build</code> folder is being copied to the web root of the Nginx web server.\nBy removing the build image afterwards (about 100MB) you will be left with a production Docker image\nwith about 15 - 20MB (the production image can also get bigger if many image assets are used in the\nproject).</p>","frontmatter":{"title":"Minified Docker images for frontend applications","date":"June 06, 2019","description":null,"author":"aschbacd"}},"previous":{"fields":{"slug":"/2019/05/mysql-search-optimization/"},"frontmatter":{"title":"MySQL search optimization"}},"next":{"fields":{"slug":"/2020/12/signed-git-commits/"},"frontmatter":{"title":"Signed Git Commits"}}},"pageContext":{"id":"df7d1e19-fc83-5d5a-b671-929542da9512","previousPostId":"8e1b8960-9b2f-5784-8715-2a339817bb11","nextPostId":"786118fb-c8e3-5af3-959f-b9fb32f3d583"}},"staticQueryHashes":["2841359383"]}